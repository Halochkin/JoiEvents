<script>
  (function () {

    /**
     * suspend and resume event listeners on window.
     */
    const reg = Symbol("eventListenerRegister");

    function equivListener(list, cb, options) {
      return list.findIndex(function (cbOptions) {
        if (cbOptions.cb !== cb)
          return false;
        const a = cbOptions.options, b = options;
        const aBool = !!(a === true || (a instanceof Object && a.capture));       //todo test if the option can be truthy or if it must be boolean true
        const bBool = !!(b === true || (b instanceof Object && b.capture));
        return aBool === bBool;
      });
    }

    Window.prototype.addEventListener = function (name, cb, options) {
      this[reg] || (this[reg] = {});
      this[reg][name] || (this[reg][name] = []);
      if (equivListener(this[reg][name], cb, options) >= 0)
        return;
      this[reg][name].push({cb, options});
      EventTarget.prototype.addEventListener.call(this, name, cb, options);
    };

    Window.prototype.removeEventListener = function (name, cb, options) {
      if (!this[reg] || !this[reg][name])
        return;
      const index = equivListener(this[reg][name], cb, options);
      if (index === -1)
        return;
      this[reg][name].splice(index, 1);
      EventTarget.prototype.removeEventListener.call(this, name, cb, options);
    };

    Window.prototype.addEventListenerFirst = function (name, cb, options) {
      this[reg] || (this[reg] = {});
      this[reg][name] || (this[reg][name] = []);

      for (let cbOptions of this[reg][name])
        EventTarget.prototype.removeEventListener.call(this, name, cbOptions.cb, cbOptions.options);

      EventTarget.prototype.addEventListener.call(this, name, cb, options);
      const index = equivListener(this[reg][name], cb, options);
      if (index >= 0)
        this[reg][name].splice(index, 1);
      this[reg][name].unshift({cb, options});

      for (let cbOptions of this[reg][name])
        EventTarget.prototype.addEventListener.call(this, name, cbOptions.cb, cbOptions.options);
    };

    /**
     * queue task in event loop
     */
    Window.prototype.queueTaskInEventLoop = function (cb) {
      if (!(cb instanceof Function))
        throw new Error("Only function references can be queued in the event loop.");
      const details = document.createElement("details");
      details.style.display = "none";
      details.ontoggle = function () {
        details.remove();
        cb();
      };
      document.body.appendChild(details);
      details.open = true;
    };

    /**
     * fix preventDefault on mouse events.
     */
    const stopPrevent = function (e) {
      e.preventDefault();
      e.stopImmediatePropagation();
    };

    const ogPreventDefault = MouseEvent.prototype.preventDefault;
    MouseEvent.prototype.preventDefault = function () {
      if (this.defaultPrevented)
        return;
      ogPreventDefault.call(this);
      if (this.type === "mouseup" && this.button === 0)
        return window.addEventListenerFirst("click", stopPrevent, {capture: true, once: true, passive: false});
      if (this.type === "mouseup")
        return window.addEventListenerFirst("auxclick", stopPrevent, {capture: true, once: true, passive: false});
      if (this.type === "mousedown" && this.button === 2)
        return window.addEventListenerFirst("contextmenu", stopPrevent, {capture: true, once: true, passive: false});
      if (this.type === "click")
        return window.addEventListenerFirst("dblclick", stopPrevent, {capture: true, once: true, passive: false});
    };


    const grabbed = Symbol("customEventsGrabbed");
    const cascadeClasses = {};                             //todo this is not strictly necessary
    const eventTypeToCascadeEvents = {};

    function callTrigger(cascadeEvent, event) {
      const combined = cascadeEvent.getObservedNames();
      cascadeEvent[event.type + "Trigger"](event);
      const combined2 = cascadeEvent.getObservedNames();
      const added = combined2.filter(name => combined.indexOf(name) === -1);
      const removed = combined.filter(name => combined2.indexOf(name) === -1);
      return {added, removed};
    }

    function _processCascadeEvents(event) {

      //1. check if the event is grabbed, if it is grabbed, then we execute the grabber and nothing else.
      //   we do not need to call the cancelCascade on the other events, as this is done sync when the events are grabbed.
      //   we need to call the cancelCascade sync when we are grabbing, because it may be called from a timer.
      //
      //   problem, the _processCascadeEvents is passive.. is that a problem?
      //   I think not, I think that active event listeners should be controlled from outside.
      //   if we want, we can just add and an active event listener when we grab/free event
      const grabber = customEvents[grabbed][event.type];
      if (grabber) {
        event.preventDefault();
        event.stopImmediatePropagation();
        grabber[event.type + "Trigger"](event);
        return;
      }

      //2. run the trigger functions up the composed path.
      //   when it is running through the cascade functions, if the cascade function is a cancelObserve, then we call cancel no matter what
      //   if the cascade function is a triggerObserve, then we check if it matches first.
      //   if one of the trigger functions call e.preventDefault(), it is not only listening on the event, but is grabbing it
      //   this will cause the _process function to flip into cancel mode.
      //   in cancel mode, the process will cancel ALL other trigger functions, except the one that was already run.
      //   this could be a problem, because the cascadeEvent functions might have changed their state and listeners.
      //   but, if everybody has a cancelMethod with a fixed name, then the call to cancel can be made all the time.
      const path = event.composedPath();
      const observers = new Set(eventTypeToCascadeEvents[event.type]);
      const listeningTriggers = [];
      for (let el of path) {
        for (let observer of observers) {
          if (observer.observedPrevented.indexOf(event.type) >= 0) {
            observer.cancelCascade(event);
            observers.delete(observer);
            continue;
          }
          if (observer.observedTriggers.indexOf(event.type) >= 0 && observer.matches(event, el)) {
            const {added, removed} = callTrigger(observer, event);
            addCascadeClass(observer, added);
            removeCascadeClass(observer, removed);
            observers.delete(observer);

            if (event.defaultPrevented) {                               //cancelMode
              for (let hasListened of listeningTriggers)
                hasListened.cancelCascade(event);
              for (let observer of observers)
                observer.cancelCascade(event);
              return;
            }
            listeningTriggers.push(observer);
          }
        }
        if (observers.size === 0)
          return;
      }
    }

    function addCascadeClass(cascadeClass, allEventTypes) {
      for (let eventType of allEventTypes) {
        if (!eventTypeToCascadeEvents[eventType]) {
          eventTypeToCascadeEvents[eventType] = new Set();
          window.addEventListenerFirst(eventType, _processCascadeEvents, true);
        }
        eventTypeToCascadeEvents[eventType].add(cascadeClass);
      }
    }

    function removeCascadeClass(cascadeClass, allEventTypes) {
      for (let eventType of allEventTypes) {
        eventTypeToCascadeEvents[eventType].delete(cascadeClass);
        if (eventTypeToCascadeEvents[eventType].size === 0) {
          delete eventTypeToCascadeEvents[eventType];
          window.removeEventListener(eventType, _processCascadeEvents, true);
        }
      }
    }

    class CustomEvents {

      constructor() {
        this[grabbed] = {};
      }

      define(CascadeEventClass) {
        if (cascadeClasses[CascadeEventClass.name])
          throw new Error("EventCascadeClass: " + CascadeEventClass.name + " is already defined.");
        const cascadeClass = new CascadeEventClass();
        cascadeClasses[CascadeEventClass.name] = cascadeClass;
        addCascadeClass(cascadeClass, cascadeClass.getObservedNames());
      }

      undefine(CascadeEventClass) {
        if (!cascadeClasses[CascadeEventClass.name])
          throw new Error("Cannot undefine EventCascadeClass: " + CascadeEventClass.name + " because it is not defined.");
        const cascadeClass = cascadeClasses[CascadeEventClass.name];
        delete cascadeClasses[CascadeEventClass.name];
        removeCascadeClass(cascadeClass, cascadeClass.getObservedNames());
      }

      /**
       * An event can be grabbed by an EventCascadeController.
       * The grabbed callback is ALWAYS ACTIVE as grabbing an event also implies overriding any default action too.
       * By setting the grab event listener to be active, scrolling from touchstart (and wheel) will always be
       * turned off in Safari and delayed in Chrome. FF doesn't react as much to active controllers.
       *
       * Netscape navigator had two methods: releaseEvents and captureEvents. These methods are remnants of the browser
       * war between netscape and MS IE. They were replaced by .stopPropagation() when Netscape's trickle down (capture)
       * and IE's bubble up event order was merged into a unified capture+bubble propagation.
       *
       * @param names
       * @param owner
       */
      grabEvents(names, owner) {
        for (let name of names) {
          if (this[grabbed][name])
            throw new Error("Event type '" + name + "' has already been grabbed!");
        }
        for (let name of names) {
          this[grabbed][name] = owner;
          //calling cancelCascade SYNC from grabEvents! Must be done to support grabEvent called from timers
          for (let cascadeEventClass of eventTypeToCascadeEvents[name] || [])
            cascadeEventClass === owner || cascadeEventClass.cancelCascade(name);
        }
      }

      freeEvents(names, owner) {
        for (let name of names) {
          if (!this[grabbed][name])
            throw new Error("Cannot free event '" + name + "' because it has not been grabbed.");
          if (this[grabbed][name] !== owner)
            throw new Error("Cannot free event '" + name + "' because it is owned by someone else.");
        }
        for (let name of names)
          delete this[grabbed][name];
      }
    }

    window.customEvents || (window.customEvents = new CustomEvents());
  })();
</script>

<script type="module">
  import {LongPressController} from "./LongPress.js";
  import {LongPress2Controller} from "./LongPress2.js";

  window.customEvents.define(LongPressController);
  window.customEvents.define(LongPress2Controller);
</script>

<div long-press>
  <div long-press-2> hello sunshine</div>
</div>

<script>
  window.addEventListener("mousedown", console.log);
  window.addEventListener("mouseup", console.log);
  window.addEventListener("click", console.log);
  window.addEventListener("long-press-activated", console.log);
  window.addEventListener("long-press", console.log);
  window.addEventListener("long-press-2-activated", console.log);
  window.addEventListener("long-press-2", console.log);
</script>