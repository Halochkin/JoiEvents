<script src="../../1b_EventLoop/demo/toggleTick.js"></script>
<script>
  const og = HTMLElement.prototype.attachShadow;
  Object.defineProperty(HTMLElement.prototype, "attachShadow", {
    value: function (opts) {
      const shadow = og.call(this, opts);
      this.__closedShadowRoot = shadow;
      return shadow;
    }
  })
</script>

<script>

  class WebComp extends HTMLElement {
    constructor() {
      super();
      const shadow = this.attachShadow({mode: "closed"});
      shadow.innerHTML = `
        <style>div{border: 5px solid gray;}</style>

        <div tabindex="3">three
          <slot></slot>
        </div>
        <div tabindex="4">four</div>`;
      addSetMyActiveElement(shadow);
    }
  }

  customElements.define("web-comp", WebComp);

  (function () {

    //function that bounces the "my-focusout" event
    function blur(targetRoots) {
      //blur, no bounce
      //blur should most definitively be composed: false.
      for (let {root, newMyActiveElement, oldMyActiveElement, blurOnly, focusOnly} of targetRoots) {
        if (focusOnly)
          continue;
        let {root, newMyActiveElement, oldMyActiveElement, blurOnly, focusOnly} = targetRoots[0];
        root.myActiveElement = root === document ? document.body : null;
        const blur = new CustomEvent("my-blur", {composed: false, bubbles: false});
        blur.relatedTarget = newMyActiveElement;
        oldMyActiveElement.dispatchEvent(blur);
        //todo do this before of after we dispatch the event?
        //todo should we add this as an event controller for focusout event?
        for (let el of getComposedPath(oldMyActiveElement)) {
          el.classList && el.classList.remove("pseudo-focus", "pseudo-focus-within");
        }
        break;
      }
    }

    function focusout(targetRoots) {
      let first = true;
      for (let {root, newMyActiveElement, oldMyActiveElement, blurOnly, focusOnly} of targetRoots) {
        if (focusOnly)
          continue;
        if (!first)
          root.myActiveElement = root === document ? document.body : null;
        const focusout = new CustomEvent("my-focusout", {composed: false, bubbles: true});
        focusout.relatedTarget = newMyActiveElement;
        oldMyActiveElement.dispatchEvent(focusout);
        //todo do this before of after we dispatch the event?
        //todo should we add this as an event controller for focusout event?
        if (!first) {
          for (let el of getComposedPath(oldMyActiveElement)) {
            el.classList && el.classList.remove("pseudo-focus", "pseudo-focus-within");
          }
        }
      }
    }

    function focus(targetRoots) {
      //focus, no bounce
      //focus should most definitively be composed: false.
      for (let {root, newMyActiveElement, oldMyActiveElement, blurOnly, focusOnly} of targetRoots) {
        if (focusOnly)
          continue;
        let {root, newMyActiveElement, oldMyActiveElement, blurOnly, focusOnly} = targetRoots[0];
        root.myActiveElement = root === document ? document.body : null;
        const blur = new CustomEvent("my-blur", {composed: false, bubbles: false});
        blur.relatedTarget = newMyActiveElement;
        oldMyActiveElement.dispatchEvent(blur);
        //todo do this before of after we dispatch the event?
        //todo should we add this as an event controller for focusout event?
        for (let el of getComposedPath(oldMyActiveElement)) {
          el.classList && el.classList.remove("pseudo-focus", "pseudo-focus-within");
        }
        break;
      }
    }

    function focusin(targetRoots) {
      let first = true;
      for (let {root, newMyActiveElement, oldMyActiveElement, blurOnly, focusOnly} of targetRoots) {
        if (focusOnly)
          continue;
        if (!first)
          root.myActiveElement = root === document ? document.body : null;
        const focusout = new CustomEvent("my-focusout", {composed: false, bubbles: true});
        focusout.relatedTarget = newMyActiveElement;
        oldMyActiveElement.dispatchEvent(focusout);
        //todo do this before of after we dispatch the event?
        //todo should we add this as an event controller for focusout event?
        if (!first) {
          for (let el of getComposedPath(oldMyActiveElement)) {
            el.classList && el.classList.remove("pseudo-focus", "pseudo-focus-within");
          }
        }
      }
    }

    function findFocusable(path) {
      for (let target of path) {
        if (target.tabIndex >= 0 || target === document.body)
          return target;
      }
      throw new Error("Can you mousedown on something not connected to the body? You shouldn't mutate the DOM during the capture phase...");
    }

    function getTargetRoot(target) {
      if (!target)
        return [];

      const result = [];
      let root = target.getRootNode();
      while (root.host) {
        result.push({target, root});
        target = root.host;
        root = target.getRootNode();
      }
      result.push({target, root});
      return result;
    }

    function blurFocusTaskList(old, nevv) {
      nevv = getTargetRoot(nevv).reverse();
      old = getTargetRoot(old).reverse();
      let i, j, k;
      const result = [];
      for (i = 0; i < old.length && i < nevv.length; i++) {
        if (old[i].root !== nevv[i].root)
          break;
        if (old[i].target === nevv[i].target)
          continue;
        result.push({root: old[i].root, oldActiveElement: old[i].target, newActiveElement: nevv[i].target});
        break;
      }
      for (j = i; j < old.length; j++)
        result.push({
          root: old[j].root,
          oldActiveElement: old[j].target,
          newActiveElement: nevv[i].target,
          blurOnly: true
        });
      for (k = i; k < nevv.length; k++)
        result.push({
          root: nevv[k].root,
          newActiveElement: nevv[k].target,
          oldActiveElement: old[i].target,
          focusOnly: true
        });
      return result.reverse();
    }

    let myActiveElementGlobal = null;
    let path;

    function blurFocus(focusoutTask, focusTask, focusinTask) {
      const focusable = findFocusable(path);
      if (focusable === myActiveElementGlobal)
        return;//here we could cancel the tasks, but we don't have to
      //we make the task list of the DOM contexts in which the myActiveElement property has changed.
      const taskList = blurFocusTaskList(myActiveElementGlobal, focusable);
      myActiveElementGlobal = focusable;

      blur(taskList);             //do blur sync in the current toggleTick macro task
      focusoutTask.reuse(focusout.bind(null, taskList));
      focusTask.reuse(focus.bind(null, taskList));
      focusinTask.reuse(focusin.bind(null, taskList));
    }

    const noOp = () => "no op";

    function addSetMyActiveElementWindow() {
      window.addEventListener("mousedown", function (e) {
        path = e.composedPath();
        //make 4 macroTasks
        let blurTask = toggleTick(noOp);
        let focusoutTask = toggleTick(noOp);
        let focusinTask = toggleTick(noOp);
        let focusTask = toggleTick(noOp);
        blurTask.reuse(() => blurFocus(focusoutTask, focusTask, focusinTask));
      }, true);
    }

    window.addSetMyActiveElement = function (root) {
      root.addEventListener("mousedown", function (e) {
        path = e.composedPath();
      }, true);
    }

    addSetMyActiveElementWindow();


  })();
</script>

<style>
  div {
    border: 10px solid red;
  }
</style>

<div id="one" tabindex="1">one</div>
<web-comp>
  <a href="#lala">Hello sunshine</a>
</web-comp>
<div id="two" tabindex="2">two</div>

<script>
  //script for debugging purposes
  const shadow = document.querySelector("web-comp").__closedShadowRoot;
  document.addEventListener("mousedown", e => {
    console.log("-----------")
    console.log("--click---------")
    console.log("outside", document.activeElement);
    console.log("MY outside", document.myActiveElement);
    console.log("inside", shadow.activeElement);
    console.log("MY inside", shadow.myActiveElement);
    toggleTick(() => {
      console.log("--click---------")
      console.log("outside toggle", document.activeElement);
      console.log("MY outside toggle", document.myActiveElement);
      console.log("inside toggle", shadow.activeElement);
      console.log("MY inside toggle", shadow.myActiveElement);
    });
  });
  document.addEventListener("focusout", e => {
    console.log("-----------")
    console.log("--focusout---------")
    console.log("outside", document.activeElement);
    console.log("MY outside", document.myActiveElement);
    console.log("inside", shadow.activeElement);
    console.log("MY inside", shadow.myActiveElement);
    toggleTick(() => {
      console.log("--focusout---------")
      console.log("outside toggle", document.activeElement);
      console.log("MY outside toggle", document.myActiveElement);
      console.log("inside toggle", shadow.activeElement);
      console.log("MY inside toggle", shadow.myActiveElement);
    });
  });
</script>