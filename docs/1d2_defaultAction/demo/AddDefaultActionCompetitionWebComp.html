<script>
  const EventRoadMap = {
    UNPREVENTABLES: {
      mousedown: ["contextmenu", "focusin", "focus", "focusout", "blur"],
      mouseup: ["click", "auxclick", "dblclick"],
      click: ["dblclick"],
      keydown: ["keypress"]
    }
  };

  function parseRaceEvents(raceEvents) {
    if (raceEvents instanceof Array)
      return raceEvents;
    if (raceEvents === undefined)
      return [];
    if (raceEvents instanceof String || typeof (raceEvents) === "string")
      return EventRoadMap.UNPREVENTABLES[raceEvents];
    throw new Error(
      "The raceEvent argument in toggleTick(cb, raceEvents) must be undefined, " +
      "an array of event names, empty array, or a string with an event name " +
      "for the trigger event in the event cascade.");
  }

  function toggleTick(cb, raceEvents) {
    raceEvents = parseRaceEvents(raceEvents);
    const details = document.createElement("details");
    details.style.display = "none";
    const internals = {
      events: raceEvents,
      cb: cb
    };

    function wrapper() {
      task.cancel();
      internals.cb();
    }

    const task = {
      cancel: function () {
        for (let raceEvent of internals.events)
          window.removeEventListener(raceEvent, wrapper, true);
        details.ontoggle = undefined;
      },
      reuse: function (newCb, raceEvents) {
        raceEvents = parseRaceEvents(raceEvents);
        internals.cb = newCb;
        for (let raceEvent of internals.events)
          window.removeEventListener(raceEvent, wrapper, true);
        internals.events = raceEvents;
        for (let raceEvent of internals.events)
          window.addEventListener(raceEvent, wrapper, {capture: true});
      },
      isActive: function () {
        return !!details.ontoggle;
      }
    };
    details.ontoggle = wrapper;
    document.body.appendChild(details);
    details.open = true;
    Promise.resolve().then(details.remove.bind(details));
    for (let raceEvent of internals.events)
      window.addEventListener(raceEvent, wrapper, {capture: true});
    return task;
  }

  //requires the toggleTick function
  Object.defineProperty(Event.prototype, "addDefaultAction", {
    value: function (cb, owner, raceEvents) {
      const self = this;
      if (owner === undefined)
        return toggleTick(() => cb(self), raceEvents);
      if (!(owner instanceof HTMLElement))
        throw new Error("The second argument 'owner' in Event.addDefaultAction(cb, owner, preEvent) must be undefined or an HTMLElement.");
      if (this.defaultPrevented)
        return;

      // the previously added default action happened below in the DOM
      // and therefore essentially calls preventDefault() on the one attempted to be added here.
      if (
        this._addedDefaultActionTriggerElement && (
        owner.contains(this._addedDefaultActionTriggerElement) ||
        owner === this._addedDefaultActionTriggerElement)
      )
        return;
      const wrapper = function () {
        if (!self.defaultPrevented)
          cb(self);
      };
      this._addedDefaultActionTriggerElement = owner;
      if (this._defaultAction)
        return this._defaultAction.reuse(wrapper, raceEvents);

      this._defaultAction = toggleTick(cb, raceEvents);
      this.preventDefault();
      Object.defineProperty(this, "defaultPrevented", {
        get: function () {
          !this._defaultAction.isActive();
        },
        set: function () {
          debugger;
        }
      });
      Object.defineProperty(this, "preventDefault", {
        value: function () {
          this._defaultAction.cancel();
        },
        writable: false
      });
    },
    writable: false
  });
</script>

<script>

  class ElOne extends HTMLElement {
    onClick(e) {
      console.log("1", this.tagName, e.type, e.target === this);
    }
  }
  customElements.define("el-one", ElOne);
  window.addEventListener("click", function (e) {
    for (let target of e.composedPath()) {
      if (target instanceof ElOne)
        e.addDefaultAction(() => target.onClick(e), target, ["dblclick"]);
    }
  }, true);




  class ElTwo extends HTMLElement {
    onClick(e) {
      console.log("2", this.tagName, e.type, e.target === this);
    }
  }
  customElements.define("el-two", ElTwo);
  //implementation of CustomEvents.define()
  //implementation of CustomActions.define(triggerEvent, action, if(target.matches), owner, raceEvents)??
  //1. the drawback of doing this this way, is that it might add the same action multiple times,
  // which will not be a problem for the element centric actions, but will be a problem for the non-element centric actions.
  // how to identify that the defaultAction added has already been added?
  // do we need to give each defaultAction a name, like that of its event?
  //2. it will run the same loop again and again, also inefficient.
  // But this is not a killer, at this stage of development. Simplicity is more important here.
  window.addEventListener("click", function (e) {
    for (let target of e.composedPath()) {
      // if (target.hasAttribute("my-draggable")){  make drag events.
      // if (target.getComputedStyle()["--my-draggable"] === "swipe"){  make swipe event.
      if (target instanceof ElTwo){
        e.addDefaultAction(() => target.onClick(e), undefined, ["dblclick"]);
        return;
      }
    }
  }, true);




  class ElThree extends HTMLElement {
    onClick(e) {
      console.log("3", this.tagName, e.type, e.target === this);
    }
  }
  customElements.define("el-three", ElThree);
  window.addEventListener("click", function (e) {
    for (let target of e.composedPath()) {
      if (target instanceof ElThree)
        e.addDefaultAction(() => target.onClick(e), target);
    }
  }, true);

</script>

<script>
  // window.addEventListener("click", e => e.preventDefault());
  window.addEventListener("click", e => console.log(e.type));
  window.addEventListener("dblclick", e => console.log(e.type));
</script>

<style>
  el-one, el-two, el-three { display: block; }
</style>


<el-one id="outer">
  one
  <el-two>
    two
    <el-three>
      three
      <el-one id="inner">
        and a one
      </el-one>
    </el-three>
  </el-two>
</el-one>

<!--<details>-->
<!--  <a href="#sunshine">-->
<!--    <summary> Hello-->
<!--      <audio src="music.mp3"></audio>-->
<!--    </summary>-->
<!--  </a>-->
<!--</details>-->

<!--<details>-->
<!--  <summary> Hello-->
<!--    <a href="#sunshine">-->
<!--      <input type="checkbox" value="world">  //3 default actions for click-->
<!--      sunshine!                              //2 default actions for click-->
<!--    </a>-->
<!--    open sesame?                             //1 default action for click-->
<!--  </summary>-->
<!--  sesame.-->
<!--</details>-->

